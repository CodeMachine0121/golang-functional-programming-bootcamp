#  Day 1 - Go 語言哲學與函數式純粹主義的碰撞

## 前言：踏上務實的 Functional Programming 之旅

今天是「Golang functional programming 深度之旅」系列的第一天。

在接下來的 30 天裡，我們的目標並不是要將 Golang 改造成 Haskell 或 Lisp，Golang 擁有他自己的設計哲學，而這正是它在系統程式設計和後端開發領域的優點之一。

因此，我們的目標是務實地從 `functional programming (FP)` 這個超級廣泛的領域中，借用其中的思想、模式與紀律，讓我們寫出更健壯、更可維護、更易於推理的 Golang code，相信這是一場關於思想碰撞與融合的探索。

> 今天，我們就從源頭開始：Golang 的設計理念，以及 functional programming 的純粹主義理想。

## Go 的核心哲學：簡潔、務實、併發

Golang 的設計者們在創造 Golang 時，心中有著非常明確的目標，這些目標形成了它的核心哲學：

### 1. 簡潔性與可讀性 (Simplicity & Readability)

#### 核心思想：「看得懂比寫得巧更重要」

想像一下，你在維護一個有 100 萬行程式碼的系統，團隊成員經常變動。Go 的設計哲學是：

- **刻意放棄複雜功能**：沒有繼承（只有組合）、沒有運算子重載、沒有 try-catch
- **強制統一風格**：`gofmt` 讓所有 Go 程式碼看起來都一樣，不管是誰寫的
- **明確的錯誤處理**：看到 `if err != nil` 就知道這裡可能出錯，強迫你處理

```go
// Go 的方式：明確但冗長
result, err := someFunction()
if err != nil {
    return err  // 你必須決定怎麼處理錯誤
}

// 其他語言可能這樣：簡潔但隱藏細節
result := someFunction()  // 錯誤在哪裡？怎麼處理？
```

### 2. 務實主義 (Pragmatism over Dogma)

#### 核心思想：「能用就好，不要為了理論犧牲實用性」

Golang 不追求「完美的程式設計理論」，而是優先考慮現實需求：

- **可變資料結構**：`slice`、`map` 都可以直接修改，因為這樣效能好、寫起來直觀
- **指標的使用**：當你要修改一個大結構體時，傳指標比複製整個結構體划算得多
- **性能優先**：如果理論上完美的做法會讓程式變慢，Golang 選擇實用的做法

```go
type User struct {
    Name string
    Age  int
    // ... 假設有很多欄位
}

// 務實的做法：傳指標，直接修改
func updateUser(u *User) {
    u.Age++  // 直接修改，效能好
}

// 理論上更「純粹」的做法：回傳新物件
func updateUserPure(u User) User {
    return User{Name: u.Name, Age: u.Age + 1}  // 複製整個結構體，慢
}
```

### 3. 內建且輕量的併發 (Built-in & Lightweight Concurrency)

#### 核心思想：「用溝通代替搶奪」

這是 Golang 最引以為傲的特色。傳統的併發程式設計像是：

- 多個人搶同一把椅子（共享記憶體），需要鎖來維持秩序
- Go 的方式：每個人有自己的工作區（Goroutine），透過傳紙條（Channel）溝通

```go
// 傳統方式：多個執行緒搶同一個變數
var counter int
var mutex sync.Mutex
mutex.Lock()
counter++  // 搶奪共享資源
mutex.Unlock()

// Go 的方式：透過 Channel 傳遞資料
ch := make(chan int)
go func() {
    ch <- 42  // 傳送資料
}()
value := <-ch  // 接收資料，不用搶
```

這種設計讓併發程式變得像寫順序程式一樣直觀，避免了**死鎖**、**競爭條件**等常見問題。

理解了這三點，我們就能明白，任何想在 Golang 中引入的模式，如果違背了簡潔性、過於晦澀難懂，或者帶來了不合理的性能開銷，那麼它很可能就是「不 Golang 的」。

## Functional Programming 的純粹主義理想

現在，讓我們轉向光譜的另一端：純粹的 functional programming，它的核心思想源自數學，特別是 λ 演算，並追求以下幾個核心原則：

- **純函數 (Pure Functions)**: 函數就像數學上的映射，對於相同的輸入，永遠回傳相同的輸出，並且在此過程中不產生任何可觀測到的副作用 (Side Effects)。副作用包括但不限於：修改外部變數、寫入資料庫、打印到控制台、發送網路請求等。
- **不可變性 (Immutability)**: 資料一旦被創建，就不能被修改。如果需要變更，那就創建一個新的資料副本並在其中包含變更。
- **表達式而非陳述式 (Expressions over Statements)**: 程式碼主要由各種表達式 (Expressions) 組成，它們會計算並回傳一個值。這與指令式程式設計中執行一系列改變狀態的陳述式 (Statements) 形成對比。
- **函數是組合的核心**: 函數可以被存儲在變數中、作為參數傳遞、或作為另一個函數的回傳值。程式的複雜性是透過將簡單的函數組合成更複雜的函數來管理的。

以上這些原則共同構建了一個優雅的程式設計模型：沒有隱藏的狀態變更，沒有難以追蹤的副作用，程式的行為變得極其可預測，易於測試和推理，並且天然地適合併發執行。

## 碰撞的火花：矛盾與權衡

當我們試圖將 FP 的純粹理想直接套用到 Golang 的世界時，劇烈的碰撞便產生了：

- **純粹性 vs. 現實世界的副作用**: Golang 是用來建構系統的，而系統程式設計本質上就是管理副作用。一個只進行純計算而無法與外部世界互動（讀寫檔案、收發網路封包）的後端服務是沒有意義的。FP 對此的答案（如 IO Monad）在 Golang 的語境下顯得相當「外來」且抽象。

- **不可變性 vs. 性能與慣例**: 在 Golang 中，對一個巨大的 struct 進行修改時，最高效的方式是傳遞它的指標並直接修改欄位。若要堅持不可變性，則意味著需要完整地複製這個 struct，這可能帶來顯著的性能開銷。Golang 的內建資料結構 slice 和 map 也都是可變的引用類型。

- **明確的 if err != nil vs. 抽象的錯誤容器**: Golang 透過 ` if err != nil ` 強制開發者正視每一個可能出錯的地方，這是一種明確的、本地化的處理方式。而 FP 中常見的 Either 或 Result 型別，雖然在組合性和鏈式呼叫上更優雅，卻引入了一層新的抽象，這對於追求簡單直接的 Golang 開發者來說可能是一個認知負擔。

那麼，以上這幾點是否意味著在 Golang 中實踐 FP 是徒勞的？絕對不是。
這場碰撞的意義不在於分出勝負，而在於找到融合點，這篇鐵人賽的核心思想是：

> 我們不追求 100% 的純粹性，而是有選擇性、有策略地應用 FP 原則來解決特定的問題。

- **擁抱「局部純粹」**: 即使整個應用程式充滿了副作用，我們依然可以將核心的業務邏輯封裝在純函數中。這些純函數不依賴外部狀態，易於平行測試，是我們程式碼中最穩固的基石。
- **提倡「受控的不可變性」**: 我們不必在所有地方都強制不可變。但在關鍵領域，特別是跨 Goroutines 共享資料時，將資料視為不可變可以從根本上消除一大類併發錯誤——資料競爭 (Data Races)。
- **發揚「組合優於繼承」**: Golang 的設計本身就鼓勵組合。我們將把這一點推向極致，大量利用高階函數來建立靈活、可重用、可插拔的軟體元件。

## 總結與明日預告

今天，我們釐清了兩種程式設計典範的核心思想以及它們之間的根本性張力。Golang 的務實主義與 FP 的數學純粹性看似背道而馳，但這也正是它們的結合點充滿潛力的地方。

> 我們的目標，就是吸收 FP 的精髓，用以增強 Golang 的威力，而不是取代它。

明天，我們將從這趟旅程的基石開始：函數。我們將超越 Golang基礎概念，深入探討如何透過柯里化 (Currying) 和部分應用 (Partial Application) 等技術，將函數的組合能力發揮到極致。